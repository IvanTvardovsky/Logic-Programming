## Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Старцев И.Р.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Методом поиска в пространстве состояний удобно решаются задачи, в которых можно перебрать все эти самые варианты состояний. Можно сказать, что Prolog подходит для решения подобных головоломок, скорость поиска решений будет зависеть от последовательности поиска и количества состояний. Перебор решений зачастую написать быстрее, чем решить задачу самостоятельно, для чего и можно использовать Prolog.

## Задание

6. Вдоль доски расположено 8 лунок, в которых лежат 4 черных и 3
белых шара. Передвинуть черные шары на место белых, а белые - на
место черных. Шар можно передвинуть в соседнюю с ним пустую
лунку, либо в пустую лунку, находящуюся непосредственно за
ближайшим шаром. При этом черные шары можно передвигать
только вправо, а белые - только влево. 

## Принцип решения

Изначально описываем все ситуации передвижения шаров с тремя позициями.

```Prolog
swap([e, w, w], X) :- X = [w, e, w].
swap([e, w, b], X) :- X = [w, e, b].
swap([e, b, w], X) :- X = [w, b, e].

swap([w, b, e], X) :- X = [w, e, b].
swap([w, e, w], X) :- X = [w, w, e].

swap([b, e, w], X) :- X = [b, w, e]; X = [e, b, w].
swap([b, e, b], X) :- X = [e, b, b].
swap([b, b, e], X) :- X = [b, e, b].
swap([b, w, e], X) :- X = [e, w, b].
```

Предикат changePosition меняет состояние системы. Он делит список на пополам с помощью append, ищет можно ли применить какое-либо правило из swap и соединяет список обратно.

```Prolog
changePosition(Start, Finish) :- append(X, [A, B, C|T], Start), swap([A, B, C], G), append(X, G, H), append(H, T, Finish).
```

Предикат checkPath меняет состояние системы и проверяет и чтобы не было зацикливания проверяет, что такого состояния не было до этого.

```Prolog
checkPath([X|T], [Y, X|T]) :- changePosition(X, Y), not(member(Y, [X|T])).
```

Предикат bfs реализуует поиск в ширину через очередь. Первый элемент - список списков, второй и третий остаются такими же. Описываем шаг (берётся первый элемент, производятся необходимые манипуляции и он помещается в конец очереди) и конец поиска. Если встречается путь, который нельзя продлить, то он удаляется из очереди и поиск продолжается с хвоста.

```Prolog
bfs([[X|T]|_], X, [X|T]).
bfs([P|QW], X, R) :- findall(Z, checkPath(P, Z), T), append(QW, T, QE), !, bfs(QE, X, R).
bfs([_|T], Y, L) :- bfs(T, Y, L).
```

Предикат path включает в себя начальное состояние X, конечное состояние Y и путь P.

```Prolog
path(X, Y, P) :- bfs([[X]], Y, P), write(P).
```

Переделать поиск в ширину в поиск в глубину несложно. Нужно только поменять элементы местами, чтобы добавлять снова полученные пути в начало очереди вместо конца. 
Берём текущий элемент -> продляем -> сразу перемещаем в начало очереди.

```Prolog
shortest(X, Y, P) :- counter(N), shortest(X, Y, P, N), !, write(P).
shortest(X, Y, P, N) :- continue([X], Y, P, N).
```

Предикает continue осуществляет поиск в глубину с ограничением - параметр N.

```Prolog
continue([X|T], X, [X|T],_).
continue(X, Y, P, N) :- N>0, checkPath(X, ZXC), N1 is N-1, continue(ZXC, Y, P, N1).
```

Также реализуем предикаты для подсчёта времени поиска.

```Prolog
time_bfs(X, Y, Time) :- get_time(Start), shortest(X, Y, _), get_time(End), Time is End - Start.

time_shortest(X, Y, Time) :- get_time(Start), path(X, Y, _), get_time(End), Time is End - Start.
```




## Результаты

```Prolog
?- shortest([b, b, b, b, e, w, w, w], [w, w, w, e, b, b, b, b], X).   
[[w,w,w,e,b,b,b,b],[w,w,e,w,b,b,b,b],[w,w,b,w,e,b,b,b],[w,w,b,w,b,e,b,b],[w,w,b,e,b,w,b,b],[w,e,b,w,b,w,b,b],[e,w,b,w,b,w,b,b],[b,w,e,w,b,w,b,b],[b,w,b,w,e,w,b,b],[b,w,b,w,b,w,e,b],[b,w,b,w,b,w,b,e],[b,w,b,w,b,e,b,w],[b,w,b,e,b,w,b,w],[b,e,b,w,b,w,b,w],[b,b,e,w,b,w,b,w],[b,b,b,w,e,w,b,w],[b,b,b,w,b,w,e,w],[b,b,b,w,b,e,w,w],[b,b,b,e,b,w,w,w],[b,b,b,b,e,w,w,w]]
X = [[w, w, w, e, b, b, b, b], [w, w, e, w, b, b, b|...], [w, w, b, w, e, b|...], [w, w, b, w, b|...], [w, w, b, e|...], [w, e, b|...], [e, w|...], [b|...], [...|...]|...].

?- path([b, b, b, b, e, w, w, w], [w, w, w, e, b, b, b, b], X).     
[[w,w,w,e,b,b,b,b],[w,w,e,w,b,b,b,b],[w,w,b,w,e,b,b,b],[w,w,b,w,b,e,b,b],[w,w,b,e,b,w,b,b],[w,e,b,w,b,w,b,b],[e,w,b,w,b,w,b,b],[b,w,e,w,b,w,b,b],[b,w,b,w,e,w,b,b],[b,w,b,w,b,w,e,b],[b,w,b,w,b,w,b,e],[b,w,b,w,b,e,b,w],[b,w,b,e,b,w,b,w],[b,e,b,w,b,w,b,w],[b,b,e,w,b,w,b,w],[b,b,b,w,e,w,b,w],[b,b,b,w,b,w,e,w],[b,b,b,w,b,e,w,w],[b,b,b,e,b,w,w,w],[b,b,b,b,e,w,w,w]]
X = [[w, w, w, e, b, b, b, b], [w, w, e, w, b, b, b|...], [w, w, b, w, e, b|...], [w, w, b, w, b|...], [w, w, b, e|...], [w, e, b|...], [e, w|...], [b|...], [...|...]|...]
```

| Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-----------------|--------------------------------|----------------|
| В глубину       |               20               |  0.02672       |
| В ширину        |               20               |  0.05153       |
| ID              |               20               |  0.01873       |


## Выводы

Я попробовал решить головоломку с помощью поиска на Prolog. Мне понравился факт, что даже в такой задаче правильный ответ можно заставить искать машину, а не заниматься этим самому.

Конкретно в данной задаче самым эффективным оказался метод поиска в глубину с ограничением, однако в других задачах такого рода возможно лучше себя покажут другие методы.
