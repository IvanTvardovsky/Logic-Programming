# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Старцев Иван Романович

## Результат проверки

Вариант задания:

 - [x] стандартный, без NLP (на 3)
 - [ ] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта я познакомлюсь со специальным форматом файлов GEDCOM, предназначенный для использования семейно-историческими программами, создам своё генеалогическое дерево, напишу скрипт для перевода данных из формата GEDCOM в предикаты Prolog, создам систему, позволяющую выяснять степень родства между людьми.

## Задание

1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM
2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog с использованием предиката `father(отец, потомок)`, `mother(мать, потомок)`.
3. Реализовать предикат проверки/поиска шурина.
4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве.

## Получение родословного дерева

Я воспользовался сервисом `www.familyecho.com` и создал своё генеалогическое дерево онлайн, после чего скачал его в формате GEDCOM. В нём 17 человек.

## Конвертация родословного дерева

Я решил использовать язык Python, потому что он хорошо себя показывает для решения задач, не требующих больших затрат по производительности и памяти. Принцип работы довольно прост - простой парсер и заполнение массивов с отцами и матерями, после заполнение выходного файла в стиле, необходимом для предикатов Prolog.

## Предикат поиска родственника

Для предиката поиска шурина были написаны вспомогательные предикаты поиска жены и поиска брата/сестры.

```prolog
wife(Husband, Wife) :-
    father(Husband, Child),
    mother(Wife, Child).

sibling(Person, Sibling) :-
    father(Father, Person),
    mother(Mother, Person),
    father(Father, Sibling),
    mother(Mother, Sibling).

shurin(Husband, Shurin) :-
    wife(Husband, Wife),
    sibling(Wife, Shurin).
```

## Определение степени родства

Начать следует с того, что в моём варианте представления отношений невозможно указать пол ребёнка, так как указываются просто отец и мать. Эта проблема решается, если ребёнок является чьим-либо отцом или матерью, но это не всегда так, поэтому такое решение не подходит.

Для начала необходимо определить минимальный набор отношений между двумя людьми. Для этого определим отношения мужа, жены, отца, матери, дочери/сына, брата/сестры и шурина.

```prolog
check(shurin, Husband, Shurin) :- shurin(Husband, Shurin).
check(husband, Wife, Husband) :- wife(Husband, Wife).
check(wife, Husband, Wife) :- wife(Wife, Husband).
check(father, Father, Child) :- father(Father, Child).
check(mother, Mother, Child) :- mother(Mother, Child).
check(child, Adult, Child) :- child(Adult, Child).
check(sibling, Person, Sibling) :- sibling(Person, Sibling).
```

Определяем счётчик, переход от поколения к поколению и глубину поиска.

```prolog
next(X, Z) :- child(X, Z).
next(X, Z) :- child(Z, X).
next(X, Z) :- sibling(X, Z).

counter(1).
counter(M) :- counter(N), (N < 5 -> M is N + 1; !, fail).
```

Находим список отношений между двумя людьми

```prolog
search(Path, X, Y, N) :- N = 1, check(A, X, Y), Path = [A].
search(Path, X, Y, N) :- N > 1, next(X, Z), N1 is N-1, search(Res, Z, Y, N1), check(B, X, Z), append([B], Res, Path).
```

Теперь реализуем сам предикат поиска отношений между людьми. Можно найти путь с помощью углубления, либо же если путь уже есть, то найти элементы с его длиной.

```prolog
relative(Res, X, Y) :- var(Res), counter(N), N < 6,  search(Res, X, Y, N), Y \= X.
relative(Res, X, Y) :- nonvar(Res), length(Res, N), search(Res, X, Y, N), Y \= X.
```

Пример работы:

```prolog
?- relative(X, 'NN', Y).
X = [husband],
Y = 'RS' ;
X = [wife],
Y = 'RS' ;
X = [mother],
Y = 'IS' ;
X = [child],
Y = 'IS' ;
```

## Выводы

Этот курсовой проект научил меня работе с генеалогическими деревьями в целом и работой с ними на языке программирования Prolog в частности. Я удивился, когда узнал, что для генеалогических деревьев существует специальный формат данных. Мне понравилось реализовывать предикаты, определяющие степень родства, потому что это действительно здорово и применимо в реальных задачах. Если бы я решил выполнять эту задачу не на логическом языке программирования, то потратил бы значительно больше сил и времени.
